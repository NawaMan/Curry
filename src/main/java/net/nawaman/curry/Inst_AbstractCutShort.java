package net.nawaman.curry;

import net.nawaman.curry.Instructions_Core.Inst_RunOnce;
import net.nawaman.util.UArray;

/**
 * An instruction that will execute one of each parameters and process them along the way. If some condition is met,
 *    the instruction may stop the execution and ignore the rest of the paramters.
 **/
abstract public class Inst_AbstractCutShort extends Instruction {
	
	// The engine will be used only for creating ISpec. It is not stored in the instruction until
	//    the instruction is actually registered.
	/** Constructs a new Instruction by using autogenerated spec. **/
	Inst_AbstractCutShort(Engine pEngine, String pISpecStr)       { super(pEngine, pISpecStr); }
	// The engine will be used only for creating ISpec. It is not stored in the instruction until
	//    the instruction is actually registered.
	/** Constructs a new Instruction by using explicitly specified spec. **/
	Inst_AbstractCutShort(Engine pEngine, InstructionSpec pISpec) { super(pEngine, pISpec); }
	
	// New Expression ----------------------------------------------------------
	
	@Override boolean checkSubExpression(int PCount, Expression[] pSubExpressions) {
		if(pSubExpressions != null)
			throw new IllegalArgumentException("This expression cannot have sub-expression ("+this.getName()+")");
		return true;
	}

	@Override final protected Expression createExpression(int pCol, int pRow, Object[] pParameters, Expression[] pSubExpressions) {
		throw new CurryError("This method should not be called because CutShort Instruction must not have sub-expressions. (Inst_AbstractCutShort.java#19)");
	}

	// Accept all as a parameter
	@Override final public Expression newExprSubs_Coordinate(int pCol, int pRow, Object[] pParameters, Expression[] pSubExpressions) {
		if(!this.checkParams(pParameters))                                                        return null;
		if(!this.checkSubExpression((pParameters == null)?0:pParameters.length, pSubExpressions)) return null;
		// Move all parameter to
		boolean IsFunctional = true;
		pSubExpressions = new Expression[pParameters.length];
		if(pParameters != null) {
			for(int i = pParameters.length; --i >= 0; ) {
				if(!(pParameters[i] instanceof Expression)) continue;
				// Move all expression to sub expression.
				pSubExpressions[i] = (Expression)pParameters[i];
				pParameters[i]     = null;
				
				if(!pSubExpressions[i].isFunctional()) IsFunctional = false;
			}
		}

		if(IsFunctional) return this.newExprComplex_Functional(pCol, pRow, this, pParameters, pSubExpressions);
		                 return this.newExprComplex(           pCol, pRow, this, pParameters, pSubExpressions);
	}
	
	// Process -----------------------------------------------------------------
	
	int RunOnceIndex = -1;
	
	private Object executeAndReplace(Context pContext, int Index, Object[] pParams, Expression[] pSubExprs) {
		if((pSubExprs == null) || (pSubExprs[Index] == null)) return pParams[Index];
		
		// Do this one.
		Expression EP = pSubExprs[Index];
		
		Object R = this.executeAnExpression(pContext, EP);
		if(R instanceof SpecialResult) {
			if(R instanceof SpecialResult.ResultReplace) {
				// To be replace
				pParams[Index]   = ((SpecialResult.ResultReplace)R).NewExpr;
				R                = ((SpecialResult.ResultReplace)R).Result;
				pSubExprs[Index] = null;
				
				if(pParams[Index] == null) pParams[Index] = R;
			}
		} else {
			// Get the RunOnceIndex
			if(this.RunOnceIndex < 0)
				this.RunOnceIndex = this.Engine.getIndexOfInstruction(net.nawaman.curry.Engine.calculateHash(Inst_RunOnce.Name));
			
			// Replace the expression with the result because it no longer need
			if(EP.isData() || (EP.getInstructionNameHash() == this.RunOnceIndex)) {
				pParams[Index]   = R;
				pSubExprs[Index] = null;
			} else if(EP.isFunctional()) {
				// See if all param of EP is data
				boolean IsAllData = true;
				Object[] EPP = ((Expression.Expr_Simple)EP).Params;
				if(EPP != null) {
					for(int j = EPP.length; --j >= 0;) {
						// It is an expression, so no functional
						if(EPP[j] instanceof Expression) {
							IsAllData = false;
							break;
						}
					}
				}
				if(IsAllData) {
					pParams[Index]   = R;
					pSubExprs[Index] = null;
				}
			}
		}
		
		if((R == null) && !ISpec.canParameterBeNull(Index)) {
			return new SpecialResult.ResultError(new CurryError("Parameter #" + Index + " must not be null.", pContext));
		}
		return R;
	}

	private Object getReturnOrReplace(Object Return, Expression pExpr) {
		Expression[] SubExprs = ((Expression.Expr_Complex)pExpr).SubExprs;
		if((SubExprs == null) || !this.ISpec.IsFunctional) return Return;	// Return
		for(int i = SubExprs.length; --i >= 0; ) {
			if(SubExprs[i] != null) return Return;
		}
		((Expression.Expr_Complex)pExpr).Params   = new Object[] { Return };
		((Expression.Expr_Complex)pExpr).SubExprs = null;
		return new SpecialResult.ResultReplace(null, Return);
	}
	
	// Config the process ------------------------------------------------------
	
	/** Judge on only one value */
	protected boolean isSingle() { return true; }
	
	/** Returns in case there is not enough value to process */
	protected Object getEarlyReturn(Context pContext, Object[] pParams) { return null; }
		
	/** Checks (for single) if this process should stop */
	protected boolean processSingleValue(Context pContext, Object O) { return true; }
		
	/** Checks (for non-single) the first item if this process should stop */
	protected boolean processFirstValue(Context pContext, Object O) { return true; }

	/** Checks (for non-single) if this process should stop */
	protected boolean processNonSingleValue(Context pContext, Object O1, Object O2) { return true; }
	
	/** Returns in case the process does not finish */
	protected Object getBreakReturn(Context pContext, Object[] pParams) { return null; }
	
	/** Returns in case the process does finish */
	protected Object getDoneReturn(Context pContext, Object[] pParams) { return null; }
	
	// Default implementation
	// Local
	@Override final protected Object run(Context pContext, Expression pExpr, Object[] pParams) {
		// Use UArray.getObjectArray(); ... to get the array
		pParams = (pParams == null)?null:UArray.getObjectArray(pParams[0]);
		if((pParams != null) && (pParams.length <= 1) && (pExpr.getSubExprCount() == 0)) {
			// Already done
			return pParams[0];
		}
		
		// Checks for early return.
		if((pParams == null) || (pParams.length <= (this.isSingle()?0:1))) {
			return this.getEarlyReturn(pContext, pParams);
		}
		
		// Use Params directly because params has only non-expression
		//    see Inst_AbstractParamsAsSubs.newExpression 
		Object[]     Params   = ((Expression.Expr_Complex)pExpr).Params;
		Expression[] SubExprs = ((Expression.Expr_Complex)pExpr).SubExprs;
		
		// This because cut short parameters will be the last one 
		boolean CannotBeNull = !((this.ISpec.PCBNs == null) || (this.ISpec.PCBNs.length < this.ISpec.Params.length));
		
		if(this.isSingle()) {
			for(int i = 0; i < Params.length; i++) {
				Object O = this.executeAndReplace(pContext, i, Params, SubExprs);
				if(CannotBeNull && (O == null))
					return this.reportParameterError(this.Engine, pContext, "Some parameter is null when it must not",
							((Expression.Expr_Simple)pExpr).Params);
				if(O instanceof SpecialResult) return O;
				
				if(this.processSingleValue(pContext, O)) {
					O = this.getBreakReturn(pContext, pParams);
					if(i != (Params.length - 1)) return O;
					else                         return this.getReturnOrReplace(O, pExpr);
				}
			}
		} else {
			// Process the first object
			Object O1 = this.executeAndReplace(pContext, 0, Params, SubExprs);
			if(CannotBeNull && (O1 == null))
				return this.reportParameterError(this.Engine, pContext, "Some parameter is null when it must not",
						((Expression.Expr_Simple)pExpr).Params);
			if(O1 instanceof SpecialResult) return O1;
			
			if(this.processFirstValue(pContext, O1)) {
				// Get the return for breaking
				Object O = this.getBreakReturn(pContext, pParams);
				if(0 != (Params.length - 1)) return O; else return this.getReturnOrReplace(O, pExpr);
			}
			
			// Process the rest in Pair
			for(int i = 1; i < Params.length; i++) {
				Object O2 = this.executeAndReplace(pContext, i, Params, SubExprs);
				if(CannotBeNull && (O2 == null))
					return this.reportParameterError(this.Engine, pContext, "Some parameter is null when it must not",
							((Expression.Expr_Simple)pExpr).Params);
				if(O2 instanceof SpecialResult) return O2;
				
				if(this.processNonSingleValue(pContext, O1, O2)) {
					Object O = this.getBreakReturn(pContext, pParams);
					if(i != (Params.length - 1)) return O; else return this.getReturnOrReplace(O, pExpr);
				}
				
				O1 = O2;
			}
		}
		
		return this.getReturnOrReplace(this.getDoneReturn(pContext, pParams), pExpr);
	}
}